<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hill Climbing</title>
    <link rel="icon" href="assets/logo.png">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="generalCss.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@2.8.0"></script>
    <script src="Sigma/sigma.min.js"></script>
    <script src="Sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes.js"></script>
    <script src="Sigma/plugins/sigma.renderers.edgeLabels/settings.js"></script>
    <script src="Sigma/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curve.js"></script>
    <script src="Sigma/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curvedArrow.js"></script>
    <script src="Sigma/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.def.js"></script>

    <script src="functions.js"></script>
    <script src="city.js"></script>
    <script src="tour-manager.js"></script>
    <script src="tour.js"></script>
    <script src="default-data.js"></script>
    <style>

        #sigma-container{
            height: 315px;
            width: 50%;
        }
        #sigma-container2{
            height: 315px;
            width: 50%;
            background-color: #D6D6D6;
        }


        #hillChart {
            background: #E1E1E1;
            width: 90%;
        }

        #leftInfo {
            width: 50%;
            background: #E1E1E1;
            padding: 12px;
        }

        #rightInfo {
            width: 50%;
            background: #D6D6D6;
            padding: 12px;
        }


    </style>
</head>
<body>
    <nav class="nav">
        <div id="nav-placeholder" ></div>
        <div id="currentAlgo" class="nav-item" style="float: right; padding-right: 50px;">
            Hill Climbing
        </div>
    </nav>

    <div class="lesson-content-container">
        <div class="lesson-container">
            <h2>Lesson - Hill Climbing</h2>

            <div class="section">
                <h3>Overview</h3>
                <p class="article">
                    Hill Climbing is one of the mathematical optimisation technique under the category of local
                    search algorithm. The algorithm starts with a random solution (random generated tour). Then,
                    a new solution is generated by swapping the order of two cities are visited. If the new
                    solution is better, then the new solution would be accepted; Else, the original solution is
                    kept. The modification process is repeated for a number of iterations or until there is no
                    more improvements.
                </p>
            </div>

            <div class="section">
                <h3>State Space Diagram</h3>
                <p class="article">
                    State space diagram is a graphical representation of the set of states our search algorithm
                    can reach (order of cities in tour) vs the value of our objective function (distance).
                </p>
                <p class="article">
                    <b>Local minimum:</b> It is a state that is better than neighbouring state. Nonetheless, there
                    exists a better state in the state space diagram. It has shorter distance compare to other
                    neighbouring tour combinations.
                </p>
                <p class="article">
                    <b>Global minimum:</b> It is the best possible state in the state space diagram. It has the
                    shortest distance among all other tour combinations.
                </p>

                <canvas id="hillChart"></canvas>
            </div>

            <div class="section">
                <h3>Pros and Cons</h3>
                <div style="padding: 25px; background-color: #E1E1E1; width: 100%; margin: auto">
                    <table class="table">
                        <tbody>
                        <tr>
                            <th scope="col">Pros</th>
                            <th scope="col">Cons</th>
                        </tr>
                        <tr>
                            <td scope="col">- Fast execution</td>
                            <td scope="col">- Dependant on initial solution</td>
                        </tr>
                        <tr>
                            <td scope="col">- Easy to implement</td>
                            <td scope="col">- Get stuck at local minimum</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="section">
                <h3>Implementation</h3>
                <h5>a) Steps</h5>
                <div class="article" style="margin-bottom: 30px;">
                    <div id="s1"><b>1.</b> Generate a random initial solution <i>i</i>. Set <i>i</i> as
                        current solution, <i>u</i></div>
                    <div id="s2"><b>2. Repeat</b></div>
                    <div id="s3"><b>3.</b>  &#8195; Generate new solution <i>k</i> by swapping 2 cities
                        in <i>u</i></div>
                    <div id="s4"><b>4.</b>  &#8195;  <b>If</b> <i>k</i> shorter than <i>u</i>,
                        replace <i>u</i> with <i>k</i></div>
                    <div id="s5"><b>5.</b>  &#8195; <b>Else</b> discard <i>k</i></div>
                    <div id="s6"><b>6.</b>  <b>Until</b> run out of time</div>
                </div>

                <div style="position: relative">
                    <h5>b) Quick Demo</h5>
                    <div style="display: flex;">
                        <div id="leftInfo">
                            <div><b>Current solution</b></div>
                            <div id="d1">Distance: </div>
                        </div>
                        <div id="rightInfo">
                            <div><b>New solution</b></div>
                            <div id="d2">Distance: </div>
                        </div>
                    </div>
                    <div style="display: flex;">
                            <div id="sigma-container"></div>
                            <div id="sigma-container2"></div>
                    </div>
                    <button style="float: right; margin-top: 10px;" id="startBtn" class="button" onclick="start()">
                        Start
                    </button>
                </div>
            </div>

            <div class="button-container">
                <a href="NN-lesson.html"><button class="button">Previous</button></a>
                <a href="SA-lesson.html"><button class="button">Next</button></a>
            </div>
        </div>
    </div>



</body>
</html>
<script>

    // chart
    Chart.plugins.register({
        afterDraw: function(chartInstance) {
            if (chartInstance.config.options.pointReferenceLetters || chartInstance.config.options.pointReferenceLetters.display) {
                var references = chartInstance.config.options.pointReferenceLetters.references || [];
                var helpers = Chart.helpers;
                var ctx = chartInstance.chart.ctx;
                var fontColor = helpers.getValueOrDefault(chartInstance.config.options.pointReferenceLetters.fontColor, chartInstance.config.options.defaultFontColor);

                // render the value of the chart above the bar
                ctx.font = Chart.helpers.fontString(Chart.defaults.global.defaultFontSize + 5, 'normal', Chart.defaults.global.defaultFontFamily);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillStyle = fontColor;

                chartInstance.data.datasets.forEach(function (dataset, dsindex) {
                    for (var i = 0; i < dataset.data.length; i++) {
                        // note, many browsers don't support the array.find() function.
                        // if you use this then be sure to provide a pollyfill
                        var refPoint = references.find(function(e) {
                            return e.datasetIndex == dsindex && e.dataIndex === i
                        });

                        if (refPoint) {
                            var model = dataset._meta[Object.keys(dataset._meta)[0]].data[i]._model;
                            ctx.fillText(refPoint.reference, model.x, model.y + 30);
                        }
                    }
                });
            }
        }
    });

    let ctx = document.getElementById("hillChart").getContext("2d");
    let hillChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: ["", "", "", "", "", "", "", "", "", "", "", ""],
            datasets: [
                {

                    data: [10,8,3,8,9,12,13,9,6,9,11,6],
                    pointRadius: 0,
                    fill: false,
                    borderColor: '#2196F3',
                }
            ]
        },
        options: {
            legend: {
                display: false,
            },
            scales: {
                xAxes: [{
                    ticks: {
                        display: false,
                    },
                    scaleLabel: {
                        display: true,
                        labelString: 'State Space',
                        fontStyle: 'bold',
                        fontColor: 'black',
                    },
                    gridLines: {
                        display: false,
                        color: 'black',
                    },
                }],
                yAxes: [{
                    ticks: {
                        min: 0,
                        max: 15,
                        display: false,

                    },
                    scaleLabel: {
                        display: true,
                        labelString: 'Objective Function',
                        fontStyle: 'bold',
                        fontColor: 'black',
                    },
                    gridLines: {
                        display: false,
                        color: 'black',
                    },
                }]
            },
            pointReferenceLetters: {
                display: true,
                fontColor: 'black',
                references: [
                    {datasetIndex: 0, dataIndex: 8, reference: 'Local Minimum'},
                    {datasetIndex: 0, dataIndex: 2, reference: 'Global Minimum'},
                ]
            },
            tooltips: {
                mode: 'index',
                intersect: true
            },
            layout: {
                padding: {
                    left: 30,
                    right: 30,
                    top: 30,
                    bottom: 30
                }
            }
        }
    });

    // sigma  node
    let s = new sigma(
        {
            renderer: {
                container: document.getElementById('sigma-container'),
                type: 'canvas'
            },
            settings: {
                minEdgeSize: 1,
                maxEdgeSize: 3,
                minNodeSize: 1,
                maxNodeSize: 10,
                enableCamera: false,
                defaultEdgeLabelSize: 15,
                defaultNodeColor: 'black',
                sideMargin: 4,
            }
        }
    );

    let s2 = new sigma(
        {
            renderer: {
                container: document.getElementById('sigma-container2'),
                type: 'canvas'
            },
            settings: {
                minEdgeSize: 1,
                maxEdgeSize: 3,
                minNodeSize: 1,
                maxNodeSize: 10,
                enableCamera: false,
                defaultEdgeLabelSize: 15,
                defaultNodeColor: 'black',
                sideMargin: 4,
            }
        }
    );

    let graph = {
        nodes: [],
        edges: []
    }

    // Program
    city1 = new City("c1", 40, 20);
    city2 = new City("c2", 55, 36);
    city3 = new City("c3", 38, 38);
    city4 = new City("c4", 26, 26);
    city5 = new City("c5", 26, 49);

    graphTM = new TourManager();
    graphTM.addCity(city1);
    graphTM.addCity(city2);
    graphTM.addCity(city3);
    graphTM.addCity(city4);
    graphTM.addCity(city5);
    tour = new Tour(graphTM.destinationCities);
    let initialSolution = new Tour(graphTM.destinationCities);
    let currentSolution = new Tour(graphTM.destinationCities);
    let newSolution = new Tour(graphTM.destinationCities);
    let stepIndex = 1;
    let step = "s1";
    let counter = 0;



    convertCityToNodes(graphTM, graph);
    updateSigma(s, graph);

    // step1();
    // step3();
    // // step4();
    // step5();

    async function auto()
    {
        while(stepIndex <= 6)
        {
            if(counter>5)
            {
                stepIndex = 6;
                step6();
            }



            if(stepIndex==1)
                step1();
            else if(stepIndex==2)
                step2();
            else if(stepIndex==3)
                step3();
            else if(stepIndex==4)
                step4();
            else if(stepIndex==5)
                step5();
            // else if(stepIndex==6)
            //     step6();
            await sleep(1500);
        }
        let x = document.getElementsByClassName("highlight");
        x[0].className = "";
        stepIndex = 1;
        enableDemo();
    }

    function step1()
    {
        currentSolution.generateIndividual();
        convertTourToEdges(currentSolution, graph);
        updateSigma(s, graph);
        step = "s" + stepIndex.toString();
        document.getElementById(step).className = "highlight";
        $("#d1").text("Distance: " + currentSolution.getDistance().toFixed(2));

        stepIndex = 2;
    }

    function step2(){
        counter++;
        updateStep();
    }

    function step3() {
        updateStep();

        newSolution.clone(currentSolution);


        let tourPos1 = -1;
        let tourPos2 = -1;

        tourPos1 = Math.floor(tour.size() * Math.random());
        tourPos2 = Math.floor(tour.size() * Math.random());

        // Skip start node
        if(tourPos1 == 0)
            tourPos1++;
        if(tourPos2 == 0)
            tourPos2++;

        // ensure no index are different
        if(tourPos1 == tourPos2)
        {
            if(tourPos1 == tour.size()-1)
            {
                tourPos1--;
            }
            else
            {
                tourPos1++;
            }
        }
        // Swap them
        newSolution.swapCities(tourPos1, tourPos2);
        convertSwapCityToNodes(newSolution, graph, tourPos1, tourPos2);
        convertTourToEdges(newSolution, graph);
        updateSigma(s2, graph);

        $("#d2").text("Distance: " + newSolution.getDistance().toFixed(2));

        if(newSolution.getDistance() < currentSolution.getDistance())
        {
            stepIndex = 4;
            currentSolution = new Tour(newSolution.getTour());
        }
        else
            stepIndex = 5;

    }

    function step4() {
        updateStep();
        convertCityToNodes(graphTM, graph);
        updateSigma(s, graph);
        stepIndex = 2;
        $("#d1").text("Distance: " + currentSolution.getDistance().toFixed(2));
    }

    function step5() {
        updateStep();
        s2.graph.clear();
        s2.refresh();
        $("#d2").text("Distance: ");
        stepIndex = 2;
    }

    function step6() {
        updateStep();
        stepIndex++;
    }


    function updateStep()
    {
        let x = document.getElementsByClassName("highlight");
        x[0].className = "";
        step = "s" + stepIndex.toString();
        document.getElementById(step).className = "highlight";
        stepIndex++;
    }

    function convertCityToNodes(TM, graph)
    {
        clearArray(graph.nodes);
        let nodeSize = 10;
        // let nodeColor = "black";
        let nodeColor = "black";
        for(let i=0;i<TM.size();i++)
        {
            graph.nodes.push(
                {
                    id: TM.getTour()[i].name,
                    label: TM.getTour()[i].name,
                    x: TM.getTour()[i].x,
                    y: TM.getTour()[i].y,
                    size: nodeSize,
                    color: nodeColor,
                }
            )
        }
    }

    function convertSwapCityToNodes(tour, graph, pos1, pos2)
    {
        clearArray(graph.nodes);
        let nodeSize = 10;
        let nodeColor = "#2196F3";
        for(let i=0;i<tour.size();i++)
        {
             if (i==pos1 || i==pos2)
                nodeColor = "#2196F3";
            else
                nodeColor = "black";

            graph.nodes.push(
                {
                    id: tour.getCity(i).name,
                    label: tour.getCity(i).name,
                    x: tour.getCity(i).x,
                    y: tour.getCity(i).y,
                    size: nodeSize,
                    color: nodeColor,
                }
            )
        }
    }

    function start() {
        disableDemo();
        resetDemo();
        auto();
    }

    function disableDemo() {
        $("#startBtn").attr("disabled", true);
        document.getElementById("startBtn"). className += " disabled";
    }

    function enableDemo() {
        $("#startBtn").attr("disabled", false);
        document.getElementById("startBtn"). className =
            document.getElementById("startBtn"). className.replace(" disabled", "");
    }

    function resetDemo()
    {
        $("#d1").text("Distance: ");
        $("#d2").text("Distance: ");
        stepIndex = 1;
        counter = 1;
        s2.graph.clear();
        s2.refresh();
        convertCityToNodes(graphTM, graph);
        updateSigma(s, graph);
    }



</script>
